# ReactiveX
## 참고
* 이해하기 어려운 코드가 있다면 [안드로이드스터디](https://github.com/taeiim/Android-Study/blob/master/study/week12/RxJava/RxJava.md)를 참고해주시면 감사하겠습니다. 
* 또한 이 레퍼지토리에서는 단순히 RxJava2만 다루지 않고 안드로이드 개발자를 위한 RxAndroid, RxKotlin도 함께 다룹니다.
* RxJava2는 한빛미디어의 RxJava 프로그래밍 책을 중심으로 작성하였습니다.

## 소개
* RxJava2를 배우기 전에 리액티브 프로그래밍이란 무엇인지, RxJava2는 무엇인지 확실하게 개념을 잡고 시작하는 편이 좋습니다.
* 다음은 이와 관련된 내용입니다.

## 리액티브 프로그래밍
* 리액티브 프로그래밍은 데이터 흐름과 전달에 관한 프로그래밍 패러다임입니다. 
* 기존 명령형 프로그래밍은 주로 컴퓨터 하드웨어를 대상으로 프로그래머가 작성항 코드가 정해진 절차에 따라 순서대로 실행됩니다.
* 그러나 리액티브 프로그래밍은 데이터 흐름을 먼저 정의하고 데이터가 변경되었을 때 연관되는 함수나 수식이 업데이트되는 방식입니다.
* 리액티브 프로그래밍을 가장 쉽게 이해할 수 있는 예는 마이크로소프트 엑셀(스프레드시트)입니다.
* 이 프로그램은 각 셀에 값을 넣거나 혹은 다른 셀을 조합해서 내가 원하는 값을 계산합니다.
* 예를 들어 회사에서 올해 1월부터 12월까지 매출액의 합을 구한다고 생각해봅니다. 월 매출은 리액티브 프로그래밍의 데이터 소스에 해당합니다. 연간 매출액은 다음처럼 매월 매출액의 합으로 산출합니다.
* 연말 매출액 = 1월 매출 + 2월 매출 + 3월 매출 + ... 12월 매출
* 그런데 최종 매출액을 결산해보니 2월 매출이 900억에서 850억으로 8월 매출이 1,200억에서 1,300억으로 늘었습니다. 이럴 때 리액티브 프로그래밍은 변경된 매출액을 다시 가져와서 총합을 구하는 방식이 아니라 매월 매출액으로 지정해놓은 데이터 소스에서 변경된 값을 전달합니다.
* 그리고 전달된 2월과 8월의 개별 값이 미리 지정해둔 수식을 통해 계산되어 연말 매출액을 갱신합니다.
* 명령형 프로그래밍 방식은 변경이 발생했다는 통지를  받아서  연말 매출액을 새로 계산하는 당겨오는 (pull) 방식이지만, 리액티브 프로그래밍은 데이터 소스가 변경된 데이터를 밀어주는 (push) 방식입니다. 일종의 옵서버 패턴입니다.
* 네크워크 프로그래밍할 때 사용하는 콜백이나 UI프로그래밍할 때 버튼 이벤트를 처리하는 클릭 리스너도 개념상으로는 리액티브 프로그래밍에 해당합니다. 이 전동적인 개념에 몇 가지 요소를 추가해야 RxJava2기반의 리액티브 프로그래밍이라고 할 수 있습니다.

## 자바 언어와 리액티브 프로그래밍
* 자바 언어와 리액티브 프로그래밍은 대략 두 가지 관계가 있습니다.
    * 기존 pull 방식의 프로그래밍 개념을 push 방식의 프로그래밍 개념으로 바꾼다.
    * 함수형 프로그래밍의 지원을 받는다.
* 자바 언어는 객체지향 프로그래밍 언어입니다. 예를 들어 앞의 연간 매출액을 계산하는 프로그램을 자바로 작성한다면 2월의 매출액이 줄어들고 8월의 매출이 늘었을 때 데이터베이스에서 월간 매출액의 합계를 가져와서(pull 방식) 결과를 다시 계산합니다. 
* 그리고 계산 시점은 아마 사용자가 <새로 고침> 버튼을 눌렀을 때가 될 것입니다. 즉, 별도의 이벤트를 받아서 다시 계산하는 방식으로 개발하지 않는다는 뜻이기도 합니다.
*  리액티브 프로그래밍에서는 데이터의 변화가 발생했을 때 변경이 발생한 곳에서 새로운 데이터를 보내(push 방식)줍니다. 기존 자바 프로그래밍이 pull 방식이라면 리액티브 프로그래밍은 push 방식입니다.
* 한편 우리가 아는 콜백이나 옵서버 패턴을 넘어서 RxJava2 기반의 리액티브 프로그래밍이 되려면 함수형 프로그래밍이 필요합니다. 콜백이나 옵서버 패턴은 옵서버가 1개이거나 단일 스레드 환경에서는 문제가 없지만 멀티 스레드 환경에서는 사용할 때 많은 주의가 필요합니다.
* 대표적인 예가 데드락과 동기화 문제입니다. 이에 관한 내용은 자바 병렬 프로그래밍과 관련한 정보를 참고하시면 좋을 듯 하네요. ㅎㅎ

#### 함수형 프로그래밍
* 함수형 프로그래밍은 부수효과가 없습니다. 콜백이나 옵서버 패턴이 스레드에 안전하지 않은 이유는 같은 자원에 여러 스레드가 경쟁 조건에 빠지게 되었을 때 예측할 수 없는 잘못된 결과가 나오기 때문입니다. 이를 부수 효과라고 합니다.
* 한두 개의 스레드가 있을 때는 정상 동작하다가 수십 수백 개의 스레드가 동시에 단일 자원에 접근하면 계산 결과가 꼬이고 디버깅하기가 매우 어렵습니다.
* 함수형 프로그래밍은 부수 효과가 없는 순수 함수를 지향합니다. 따라서 멀티 스레드 환경에서도 안전합니다. 자바 언어로 리액티브 프로그래밍을 하기 위해서는 함수형 프로그래밍의 지원이 필요합니다.

## 리액티브 프로그래밍 개념 잡기
* RxJava를 비롯한 리액티브 프로그래밍을 공부하다 보면 새롭게 등장하는 개념때문에 혼란에 빠질 때가 있다고 합니다. 프로그래밍  스타일도 다르고 프로그래머가 문제를 바라봐야 하는 관점도 달라지기 때문입니다. 그러나 새로운 개념을 잘 이해하면 이후에 공부하기가 수월해지므로 기초 개념을 잡고 시작해야합니다.
* 리액티브 프로그래밍은 데이터 흐름과 변화의 전달에 관한 프로그래밍 패러다임입니다. 위키백과의 'Reactive programming'에서는 컴퓨터 프로그램의 세 가지 분류 중 한 가지로 소개하기도 합니다. 다음은 중요한 내용의 번역본입니다.
* **컴퓨터 프로그래밍에는 크게 세 가지 종류가 있습니다.**
    * **첫 번째는 변환 프로그램으로 주어진 입력값을 바탕으로 결과를 계산하는 프로그램입니다. 일반적인 예는 컴파일러와 수치 계산 프로그램입니다.**
    * **두 번째는 상호작용 프로그램으로 프로그램이 주도하는 속도로 사용자 혹은 다른 프로그램과 상호작용합니다. 사용자의 관점으로 볼 때 시분할 시스템은 상호작용 프로그램입니다. 리액티브 프로그램은 주변의 환경과 끊임없는 상호작용하을 하는데 프로그램이 주도하는 것이 아니라 환경이 변하면 이벤트를 받아 동작합니다. 상호작용 프로그램은 자신의 속도에 맞춰 일하고 대부분 통신을 담당합니다. 반면 리액티브 프로그램은 외부 요구에 반응에 맞춰 일하고 대부분 정확한 인터럽트 처리를 담당합니다.**
* 다소 원론적이지만 리액티브 프로그래밍을 이해하는 데 필요한 개념이 담겨 있습니다. 보통 어플리케이션을 만드는 프로그래머가 작성하는 프로그램은 변환 프로그램이거나 상호작용 프로그램입니다. 인터럽트 같은 개념은 시스템 프로그래머가 담당합니다.
* 혹은 클라이언트의 요청을 처리하는 서버 프로그래밍은 리액티브 프로그래밍에 가깝습니다. 어플리케이션에서 RxJava2와 같은 리액티브 프로그래밍을 하려면 누군가 리액티브 프로그래밍을 할 수 있는 기반 시설을 제공해주어야 합니다.
* 즉, 데이터 소스를 정의할 수 있고 그것의 변경 사항을 받아서 내 프로그램에 알려줄 존개가 필요합니다. 그것을 .NET 환경에서는 리액티브 확장이라고 하고 JVM 위의 자바 언어로 구현해놓은 라이브러리가 RxJava2입니다. 

## RxJava가 생긴 이유
* 넷플릭스의 REST 기반의 서비스 API 호출 횟수와 서비스의 전반적인 성능을 개선하는 프로젝트에서 생겨났습니다. 핵심 이유는 다음과 같습니다.
    * 동시성을 적극적으로 끌어안을 필요가 있다(Embrace Concurrency)
    * 자바 Future를 조합하기 어렵다는 점을 해결해야 한다.(Java Futures are Expensive to Compose)
    * 콜백 방식의 문제점을 개선해야 한다.(Callbacks Have Their Own Problems).

* 첫 번째 이유의 원인은 자바가 동시성 처리를 하는 데 번거로움이 있기 때문입니다. 이를 해결하려고 넥플릭스는 클라이언트의 요청을 처리하는 서비스 계층에서 동시성을 적극적으로 끌어안았습니다. 클라이언트의 요청을 처리할 때 다수의 비동기 실행 흐름(스레드 등)을 생성하고 그것의 결과를 취합하여 최종 리턴하는 방식으로 내부 로직을 변경했습니다.
* 두 번째 이유의 원인은 2013년 당시 자바 8에서 제공하는 CompletableFuture 같은 클래스가 제공되지 않았기 때문입니다. 그래서 비동기 흐름을 조합할 방법이 거의 없었습니다. RxJava2에서는 이를 해결하려고 비동기 흐름을 조합할 수 있는 방법을 제공합니다. RxJava2에서는 조합하는 실행 단위를 리액티브 연산자라고 합니다.
* 세 번째 이유의 원인은 콜백이 콜백을 부르는 콜백 지옥 상황이 코드의 가독성을 떨어뜨리고 문제 발생 시 디버깅을 어렵게 만들기 때문입니다. 비동기 방식으로 동작하는 가장 대표적인 프로그래밍 패텅은 콜백입니다, 그래서 RxJava2는 콜백을 사용하지 않는 방향으로 설계해 이를 해결했습니다.
* 리액티브 프로그래밍은 비동기 연산을 필터링, 변환, 조합해 위 세 가지 핵심 이류를 해결할 수 있습니다. 따라서 RxJava2는 Observable과 같은 데이터 소스와 map(), filter(), reduce()와 같은 리액티브 연산자를 제공합니다.
